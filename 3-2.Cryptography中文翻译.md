以下是文件内容的完整翻译：

---

**COMP4137 区块链技术与应用 COMP7200 区块链技术**

**授课教师：Dr. Hong-Ning Dai (Henry)**

**第2讲**

**密码学**

**大纲**

- 密码学简介
- 古典密码
- 计算机密码学

**密码学 ≠ 安全性**

- 密码学可能是安全系统的一个组成部分。
- 添加密码学并不一定能使系统安全。

**术语**

- 明文（明文）用消息 M 表示。
- 加密用函数 E(M) 表示。
- 加密后产生密文，用 C=E(M) 表示。
- 解密密文并获得原始消息 M=D(C)。
- 密码：密码学算法。

**密码类型**

- 限制性密码
- 对称算法
- 公钥算法

**限制性密码**

- 秘密算法
- 泄露
- 反向工程
- HD DVD（2006年12月）和蓝光（2007年1月）
- RC4
- 所有数字蜂窝加密算法
- DVD 和 DIVX 视频压缩
- Firewire
- Enigma 密码机
- 冷战期间北约和华约的所有算法

**密钥**

*顺便说一下，上面的是撞锁钥匙。见 http://en.wikipedia.org/wiki/Lock_bumping。*

**密钥**

*来源：en.wikipedia.org/wiki/Pin_tumbler_lock*

**密钥**

*来源：en.wikipedia.org/wiki/Pin_tumbler_lock*

**密钥**

- 我们了解它是如何工作的：
  - 优点
  - 缺点
- 基于这种理解，我们可以评估对密钥和锁的信任程度。

**对称算法**

- 秘密密钥
- C = EK(M)
- M = DK(C)

**公钥算法**

- 公钥和私钥
- C1 = Epublic(M)
- M = Dprivate(C1)
- 同样：
- C2 = Eprivate(M)
- M = Dpublic(C2)

**麦卡锡难题（1958年）**

- 两个国家处于战争状态。
- 一个国家向另一个国家派遣间谍。
- 为了安全返回，间谍必须向边境卫兵提供密码。
- 间谍是可信的。
- 卫兵会聊天——他们获得的信息可能会泄露。

**挑战！**

卫兵如何在不知道密码的情况下验证一个人的身份？敌人不能利用卫兵的知识引入自己的间谍。

**麦卡锡难题的解决方案**

迈克尔·拉宾，1958年

使用单向函数，B=f(A)

- 卫兵获得 B……
- 敌人无法计算出 A
- 间谍提供 A，卫兵计算 f(A)
- 如果结果是 B，则密码正确。

**示例函数：**

中间平方

- 取一个100位的数字（A），并将其平方
- 让 B = 200位结果的中间100位数字

**麦卡锡难题示例**

使用一个18位数字的示例

A = 289407349786637777

A² = 83756614110525308948445338203501729

中间平方，B = 110525308948445338

已知 A，计算 B 很容易。

已知 B，计算 A 非常困难。

**单向函数**

- 在一个方向上容易计算。
- 在另一个方向上难以计算。

**示例：**

因式分解：

- pq = N（容易）
- 已知 N 求 p,q（困难）

离散对数：

- ab mod c = N（容易）
- 已知 a, c, N 求 b（困难）

**更多术语**

- 单向函数
- 拉宾，1958年：麦卡锡问题
- 中间平方、指数运算……
- [单向] 哈希函数
- 消息摘要、指纹、密码校验和、完整性检查
- 加密哈希
- 消息认证码
- 只有密钥持有者才能验证消息

**更多术语**

- 流密码
  - 逐字符加密消息
- 分组密码
  - 逐块加密消息
- 数字签名
  - 验证消息，而不是加密消息
  - 使用一对密钥（私钥、公钥）
  - 消息所有者用自己的私钥加密消息
  - 接收者用公钥解密验证
  - 通常使用哈希（消息）。

**大纲**

- 密码学简介
- 古典密码
- 计算机密码学

**密码学的作用**

- 身份验证
  - 确认消息来源
- 完整性
  - 验证消息是否被篡改
- 不可否认性
  - 发送者不能虚假否认发送过消息
- 保密性
  - 其他人无法阅读消息内容

**凯撒密码**

最早的密码学军事应用记录

- 公元前60年左右的尤利乌斯·凯撒
- 移位密码：替换密码的简单变体
- 每个字母被替换为字母表中 n 个位置后的字母
- n = 移位值 = 密钥
- 印度也曾使用过类似的方案
- 古印度人还使用基于音系的替换，类似于“猪拉丁语”
- 最后一次出现在 Usenet 上，用于防止读者无意中看到冒犯性信息

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

U V W X Y Z A B C D E F G H I J K L M N O P Q R S T

字母表移位 n（6）

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

G

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GS

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSW

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWU

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUN

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNB

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNBU

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNBUM

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNBUMZ

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNBUMZF

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNBUMZFY

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C

C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNBUMZFYU

**凯撒密码**

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

MY CAT HAS FLEAS

GSWUNBMUFZYUM

**凯撒密码**

- 解密需要传递一个信息：移位值。
- 非常容易破解（对于26个字符的字母表，只有26种可能）。

**古代希伯来变体（ATBASH）**

- 公元前600年左右
- 不需要传递任何信息（密钥）！

**替换密码**

- 一般情况：任意映射
- 双方必须拥有相同的替换字母表

**替换密码**

容易破解：

- 易受频率分析攻击

《白鲸记》《莎士比亚全集》

（120万字符）（5580万字符）

e 12.300% e 11.797%

o 7.282% o 8.299%

d 4.015% d 3.943%

b 1.773% b 1.634%

x 0.108% x 0.140%

**统计分析**

字母频率

E：12% A、H、I、N、O、R、S、T：6% - 9% D、L：4% B、C、F、G、M、P、U、W、Y：1.5% - 2.8% J、K、Q、V、X、Z：<1%

常见双字母组合：

TH、HE、IN、ER、AN、RE……

常见三字母组合：

THE、ING、AND、HER、ERE……

**强密码：**

- 至少12个字符，14个或更多更好。
- 包含大写字母、小写字母、数字和符号的组合。

**大纲**

- 密码学简介
- 古典密码
- 计算机密码学

**DES（数据加密标准）**

- 1976年被采纳为联邦标准
- 分组密码，64位分组
- 56位密钥
- 安全性完全依赖于密钥
- 先进行替换，再进行置换（排列）
- 同样的技术组合在明文分组上重复16次

**DES**

64位明文分组

初始置换，IP

左半部分，L₀ 右半部分，R₀

f

R₁ = L₀ ⊕ f(R₀, K₁) L₁ = R₀

K₁

16轮

L₁₅ = R₁₄ R₁₅ = L₁₄ ⊕ f(R₁₄, K₁₅)

从密钥中置换出的48位子密钥

f

L₁₆ = R₁₅ R₁₆ = L₁₅ ⊕ f(R₁₅, K₁₆)

K₁₆

最终置换，IP⁻¹

64位密文分组

**DES：f 函数**

数据：右侧32位 密钥：56位

数据：左侧32位 新数据：右侧32位

48位 48位

S S S S S S S S

**DES：S盒**

- 压缩后的密钥与扩展后的分组进行异或运算后
- 48位结果通过8个替换盒（S盒）进行替换操作
- 每个S盒有
  - 6位输入
  - 4位输出
- 48位数据被分成8个6位子分组
- 每个子分组由一个单独的S盒处理
- 是DES安全性的关键组成部分
- 最终结果：48位输入生成32位输出

**DES是否安全？**

56位密钥使DES相对不安全

- 7.2×10¹⁶个密钥
- 暴力攻击

20世纪90年代末：

- DES破解机可以在几小时内破解DES密钥
- DES Deep Crack：每秒尝试900亿个密钥
- Distributed.net：每秒尝试2500亿个密钥

**2的幂次**

密钥增加一位会使搜索空间翻倍。

假设破解一个20位密钥需要1秒：

- 21位密钥：2秒
- 32位密钥：1小时
- 40位密钥：12天
- 56位密钥：2178年
- 64位密钥：超过55.7万年！

**增加密钥长度**

双重加密对DES是否有效？

- 如果能找到一个密钥K，使得：

EK(P) = EK₂(EK₁(P))

- 对DES来说，这种情况不存在

**双重DES**

容易受到中间相遇攻击

如果我们知道一对（P, C），那么：

- [1] 用所有2⁵⁶个可能的K₁值对P进行加密
- [2] 用所有2⁵⁶个可能的K₂值对C进行解密

对于每个[1] = [2]的匹配项：

- 用另一对P, C测试这两个密钥
- 如果匹配，那么你就确定找到了正确的密钥

**三重DES**

使用两个56位密钥的三重DES：

C = EK₁(DK₂(EK₁(P)))

使用三个56位密钥的三重DES：

C = EK₃(DK₂(EK₁(P)))

中间步骤使用解密是为了与DES兼容（K₁=K₂=K₃=k）

C = EK(DK(EK(P))) ≡ C = EK₁(P)

**三重DES**

通过

- 三个阶段
- 和两个密钥

防止中间相遇攻击

三重DES：

C = EK₁(DK₂(EK₁(P)))

中间步骤使用解密是为了与DES兼容

C = EK(DK(EK(P))) ≡ C = EK₁(P)

**流行的对称算法**

IDEA - 国际数据加密算法

- 1992年
- 128位密钥，处理8字节分组（与DES相同）
- 算法比DES更安全

RC4，由Ron Rivest设计

- 1995年
- 密钥长度可达2048位
- 对于用相同密钥加密的多条消息不安全

AES - 高级加密标准

- NIST提议的DES替代方案，于2000年10月选定
- 基于Rijndael密码
- 密钥长度为128位、192位和256位

**AES（高级加密标准）**

来自NIST：

假设你能制造一台机器，能在1秒内破解一个DES密钥（即每秒尝试2⁵⁶个密钥），那么这台机器需要大约149万亿年才能破解一个128位的AES密钥。作为对比，宇宙被认为不到200亿年。

*http://csrc.nist.gov/encryption/aes/*

**对称密码学**

- 双方必须就一个密钥K达成一致
- 消息被加密、发送并在另一端解密
- 密钥分发必须保密
  - 否则消息可以被解密
  - 用户可以被冒充

**密钥爆炸问题**

每对用户都需要一个单独的密钥进行安全通信

- 2个用户：1个密钥
- 3个用户：3个密钥
- 4个用户：6个密钥
- 6个用户：15个密钥
- 100个用户：4950个密钥
- 1000个用户：399500个密钥
- n个用户：(n² - n)/2个密钥

**密钥分发**

对称密码学最大的问题是密钥的安全分发

如何与一个从未见过面的人安全地通信？

惠特·迪菲：提出了公钥算法的想法

挑战：这能安全地实现吗？

知道公钥不应允许推导出私钥

**迪菲-赫尔曼指数密钥交换**

密钥分发算法

- 第一个使用公钥/私钥的算法
- 不是公钥加密
- 基于在有限域中计算离散对数的困难性，与计算指数的容易性相比

允许我们在不担心窃听者的情况下协商一个秘密会话密钥

**迪菲-赫尔曼指数密钥交换**

- 所有算术运算都在某个大数的模运算整数域中进行
- 双方同意
  - 一个大素数 p
  - 一个数 α < p
- 每方生成一对公钥/私钥
  - 用户 i 的私钥：Xi
  - 用户 i 的公钥：Yi

**迪菲-赫尔曼指数密钥交换**

- 爱丽丝有私钥 XA
- 爱丽丝有公钥 YA
- 爱丽丝计算

- 鲍勃有私钥 XB
- 鲍勃有公钥 YB

**迪菲-赫尔曼指数密钥交换**

- 爱丽丝有私钥 XA
- 爱丽丝有公钥 YA
- 爱丽丝计算

- 鲍勃有私钥 XB
- 鲍勃有公钥 YB
- 鲍勃计算

K' =（爱丽丝的公钥）（鲍勃的私钥）mod p

**迪菲-赫尔曼指数密钥交换**

- 爱丽丝有私钥 XA
- 爱丽丝有公钥 YA
- 爱丽丝计算

- 鲍勃有私钥 XB
- 鲍勃有公钥 YB
- 鲍勃计算

K 是爱丽丝和鲍勃唯一知晓的共同密钥

K = K'

**迪菲-赫尔曼示例**

爱丽丝选择

XA = 18

爱丽丝的公钥是：

YA = 7¹⁸ mod 31667 = 6780

K = 22184¹⁸ mod 31667

K = 14265

鲍勃选择

XB = 27

鲍勃的公钥是：

YB = 7²⁷ mod 31667 = 22184

K = 6780²⁷ mod 31667

K = 14265

假设 p = 31667，α = 7

**密钥分发问题解决了！**

- 用户保留私钥
- 在数据库（“电话簿”）中发布公钥
- 通信从密钥交换开始，以建立一个共同密钥
- 可以用共同密钥加密一个会话密钥
- 通过减少用它加密的数据量来增加破解共同密钥的难度
- 会话密钥仅对一次通信会话有效

**RSA：公钥密码学**

- 1977年，罗恩·里维斯特、阿迪·萨莫尔和伦纳德·阿德勒曼发明了一种真正的公钥加密算法
- 每个用户生成两把密钥
  - 私钥（保密）
  - 公钥
- 算法的难度基于分解大数的困难性
- 密钥是基于一对大约200位的大素数的函数

**RSA算法**

生成密钥：

- 随机选择两个大的素数 p 和 q
- 计算乘积 n = pq
- 随机选择加密密钥 e，使得：

e 和 (p - 1)(q - 1) 互质

- 使用扩展欧几里得算法计算解密密钥 d：

ed = 1 mod ((p - 1) (q - 1))

d = e⁻¹ mod ((p - 1) (q - 1))

- 丢弃 p 和 q

**RSA算法**

加密：

- 将数据分成小于 n 的数值块
- 加密每个块：

c = mᵉ mod n

解密：

m = cᵈ mod n

**使用公钥算法进行通信**

加密和解密使用不同的密钥

- 不必担心密钥分发问题

**使用公钥算法进行通信**

爱丽丝 鲍勃

爱丽丝的公钥：KA

鲍勃的公钥：KB

交换公钥

（或在目录/数据库中查找）

**使用公钥算法进行通信**

爱丽丝 鲍勃

爱丽丝的公钥：KA

鲍勃的公钥：KB

EB(P)

Db(C)

爱丽丝 鲍勃

爱丽丝的公钥：KA

鲍勃的公钥：KB

用鲍勃的公钥加密消息

用鲍勃的私钥解密消息

**使用公钥算法进行通信**

爱丽丝 鲍勃

爱丽丝的公钥：KA

鲍勃的公钥：KB

EB(P)

Db(C)

爱丽丝 鲍勃

爱丽丝的公钥：KA

鲍勃的公钥：KB

Da(C)

EA(P)

用爱丽丝的私钥解密消息

用爱丽丝的公钥加密消息

用鲍勃的公钥加密消息

用鲍勃的私钥解密消息

**公钥的困境**

公钥密码学很好，但：

- RSA在软件中比DES慢100倍，在硬件中慢1000倍
- 容易受到已知明文攻击
  - 如果你知道数据是 n 条消息之一，只需用接收者的公钥加密每条消息并进行比较
- 最好减少用任何给定密钥加密的数据量
  - 但生成RSA密钥在计算上非常耗时

**签名**

*来源：http://www.archives.gov/exhibits/charters/declaration.html*

我们使用签名是因为签名具有以下特性：

- 真实性
- 不可伪造性
- 不可重复使用
- 不可抵赖性
- 使文件不可更改

**签名**

我们使用签名是因为签名具有以下特性：

- 真实性
- 不可伪造性
- 不可重复使用
- 不可抵赖性
- 使文件不可更改

**数字签名 - 仲裁协议**

使用对称加密的仲裁协议

- 向可信第三方（仲裁者）求助以验证消息

**仲裁协议**

爱丽丝 鲍勃

特伦特

C=EA(P)

爱丽丝用自己的密钥加密消息并发送给特伦特

特伦特是可信的

并且拥有所有人的密钥

**仲裁协议**

爱丽丝 鲍勃

特伦特

P= DA(C)

特伦特收到爱丽丝的消息并用爱丽丝的密钥解密

- 这验证了消息来自爱丽丝

- 他可能会记录消息的哈希值，以创建传输记录

**仲裁协议**

爱丽丝 鲍勃

特伦特

特伦特现在用鲍勃的密钥加密消息并发送给鲍勃

C’= EB(P)

**仲裁协议**

爱丽丝 鲍勃

特伦特

鲍勃收到消息并解密

- 它一定是特伦特发来的，因为只有特伦特和鲍勃拥有鲍勃的密钥

- 如果消息声称来自爱丽丝，那一定是真的——我们信任特伦特

P’= DB(C’)

**数字签名 - 公钥密码学**

Ea(P)

DA(C)

爱丽丝 鲍勃

用爱丽丝的私钥加密消息

用爱丽丝的公钥解密消息

用私钥加密消息等同于签名！

**数字签名 - 公钥密码学**

- 如果爱丽丝向鲍勃发送二进制数据怎么办？

- 鲍勃可能很难知道解密是否成功

- 公钥加密比对称加密慢得多

  - 如果消息很大怎么办？

- 如果我们不想隐藏消息，但需要一个有效的签名怎么办？

**数字签名 - 公钥密码学**

- 对消息进行哈希处理

- 加密哈希值并与消息一起发送

- 通过解密哈希值并与收到的消息的哈希值进行比较来验证哈希值

- 现在签名与消息是独立的实体

**数字签名 - 公钥密码学**

爱丽丝 鲍勃

H(P)

爱丽丝生成消息的哈希值

**数字签名 - 公钥密码学**

爱丽丝 鲍勃

H(P)

爱丽丝用自己的私钥加密哈希值

Ea(H(P))

**数字签名 - 公钥密码学**

爱丽丝 鲍勃

H(P)

爱丽丝将消息和加密的哈希值发送给鲍勃

Ea(H(P))

**数字签名 - 公钥密码学**

爱丽丝 鲍勃

H(P)

1. 鲍勃用爱丽丝的公钥解密哈希值

2. 鲍勃计算爱丽丝发送的消息的哈希值

C = Ea(H(P))

H(P)

H’ = DA(C)

**数字签名 - 公钥密码学**

爱丽丝 鲍勃

H(P)

如果哈希值匹配

- 加密的哈希值一定是爱丽丝生成的

- 签名有效

C = Ea(H(P))

H(P)

H’ = DA(C)

**公钥/私钥和数字签名的演示**

- 公钥/私钥对

  *https://andersbrownworth.com/blockchain/public-private-keys/keys*

- 数字签名

  *https://andersbrownworth.com/blockchain/public-private-keys/signatures*

**密码学工具箱**

- 对称加密
- 公钥加密
- 单向哈希函数
- 随机数生成器
- 随机数、会话密钥

**示例**

- 密钥交换
- 公钥密码学
- 密钥交换 + 安全通信
- 公钥 + 对称密码学
- 身份验证
- 随机数 + 加密
- 消息认证码
- 哈希值
- 数字签名
- 哈希值 + 加密
